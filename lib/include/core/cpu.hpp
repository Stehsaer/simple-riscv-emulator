#pragma once

#include "alu.hpp"
#include "common/type.hpp"
#include "decode.hpp"
#include "memory.hpp"
#include "register-file.hpp"

#include <array>
#include <functional>
#include <memory>
#include <optional>
#include <utility>

namespace core
{
	/**
	 * @brief RV32 CPU Module
	 * 
	 */
	struct CPU_module
	{
		/**
		 * @brief CPU execution result.
		 * 
		 */
		struct Result : public Inst_decode_module::Result
		{
			u32 pc = 0;
			u32 inst = 0;

			std::optional<Trap> trap;
			u32 alu_result;
			bool branch_result;
			u32 csr_result;
			u32 memory_load_value;
			u32 writeback_value;

			Result& operator=(const Inst_decode_module::Result& other) noexcept
			{
				Inst_decode_module::Result::operator=(other);
				return *this;
			}
		};

		/* CPU States */

		u32 pc;

		bool waiting_for_interrupt = false;
		Inst_fetch_module inst_fetch;
		Register_file_module registers;
		Inst_decode_module decoder;
		ALU_module alu;
		Branch_module branch;
		Load_store_module memory;
		CSR_module csr;

		/* Interfaces */

		std::shared_ptr<Memory_interface> interface;

		/* Constructor */

		CPU_module(u32 init_pc, std::shared_ptr<Memory_interface> interface) :
			pc(init_pc),
			interface(std::move(interface))
		{
		}

		/* Emulate */

		/**
		 * @brief Execute command and generates `Trap` if needed
		 * 
		 * @return Result of the execution
		 */
		Result execute();

		/**
		 * @brief Handle trap generated by `execute()`
		 * @note This can be called safely even if no trap is generated.
		 * @param result Result from `execute()`
		 */
		void handle_trap(const Result& result);

		/**
		 * @brief Fully emulates 1 CPU cycle
		 * 
		 * @return Result of the emulation
		 */
		Result step();
	};
}
